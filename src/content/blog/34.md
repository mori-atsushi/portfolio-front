---
title: 'LiveData vs Flow vs RxJava'
description: 'Kotlin Coroutinesの進化はすざましく、とどまるところを知りません。\n状態やイベントを扱いやすくなったStateFlowやSharedFlowが登場し、さらには、Lifecycleをより扱いやすくなったLifecycleOwner.addRepeatingJobやLifecycleOwner.repeatOnLifecycle、Flow.flowWithLifecycleが追加されました。\nRoomやDataStore等Jetpackの各種ライブラリでもCoroutinesが使われており、Jetpack Composeでも様々なところでCoroutinesが活用されています。\nそういった中で、一部LiveDataやRxJavaからCoroutinesに書き直す動きが見られ、多少混乱を招いていると感じています。\n結論から言うと、現時点において積極的にCoroutinesに移行する必要性はないと考えています。\n今回は、それらを比較しつつ、どういった使い分けをするのが好ましいのか私の視点からまとめます。'
pubDate: '2021-03-28T06:00:00.000Z'
ogpImage: 'https://cdn.at-sushi.work/temp/2021-03-28-ogp.png'
---

[Kotlin Coroutines](https://github.com/Kotlin/kotlinx.coroutines)の進化はすざましく、とどまるところを知りません。

状態やイベントを扱いやすくなった[StateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/)や[SharedFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/)が登場し、さらには、Lifecycleをより扱いやすくなった[LifecycleOwner.addRepeatingJob](https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/package-summary?hl=id-IDCache#addrepeatingjob)や[LifecycleOwner.repeatOnLifecycle](https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/package-summary?hl=id-IDCache#repeatonlifecycle)、[Flow.flowWithLifecycle](https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/package-summary?hl=id-IDCache#flowwithlifecycle)が追加されました。

[Room](https://developer.android.com/jetpack/androidx/releases/room)や[DataStore](https://developer.android.com/jetpack/androidx/releases/datastore)等Jetpackの各種ライブラリでもCoroutinesが使われており、[Jetpack Compose](https://developer.android.com/jetpack/compose)でも様々なところでCoroutinesが活用されています。

そういった中で、一部[LiveData](https://developer.android.com/topic/libraries/architecture/livedata)や[RxJava](https://github.com/ReactiveX/RxJava)からCoroutinesに書き直す動きが見られ、多少混乱を招いていると感じています。

結論から言うと、現時点において積極的にCoroutinesに移行する必要性はないと考えています。

今回は、それらを比較しつつ、どういった使い分けをするのが好ましいのか私の視点からまとめます。

## 各々の特徴
軽く特徴を紹介します。

### LiveData
`LiveData`はJetpackライブラリ群の一つです。

`Lifecycle` を考慮した`Observable`であり、`onStop`時に自動で購読を解除してくれ、`onStart`時に再開をしてくれます。

値を保持することに特化しており、購読時に最新の値を通知してくれます。

そのため、イベント通知にはそのまま使うことは出来ません。

### Flow
`Flow`は`Kotlin Coroutines`において値を複数回送信することができる`Interface`です。

状態を表現するための`StateFlow`や、イベント通知のための`SharedFlow`が存在します。

`Kotlin Coroutines`の`suspend function`や`Channel`とも当然相性が良いです。

### RxJava
`RxJava`は`ReactiveX`の`Java`実装です。

`ReactiveX`はStreamを用いて非同期かつイベントベースのプログラミングを実現するためのライブラリです。

様々な言語で利用可能になっています。

Kotlinへの拡張を持った`RxKotlin`も提供されています。

## 比較
それぞれを各観点から比較します。

### Lifecycle
非同期処理をAndroidアプリ開発で扱うにおいて、困難なポイントにLifecycleがあります。

安易に非同期処理を扱うと、`onDestory`以降で`View`を参照してクラッシュしたり、バックグラウンドになっているのにも関わらず不要にリソースを消費する可能性があります。

`LiveData` は強力に`Lifecycle`をサポートします。

`Flow`に関しては`livedata-ktx`にて[launchWhenStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope#launchwhenstarted)等の`Lifecycle`に従うツールが提供されています。

しかし、`launchWhenStarted`を`Flow`に対して使う際は、バッファに関して注意が必要です。

それの課題を解決し、より扱いやすくした`LifecycleOwner.addRepeatingJob`、`LifecycleOwner.repeatOnLifecycle`、`Flow.flowWithLifecycle`が登場しましたが、まだ[α版での提供](https://developer.android.com/jetpack/androidx/releases/lifecycle#version_240_2)になっています。

---

**2021-04-06 追記**
* [launchWhenXXとaddRepeatingJobの違い【Android / Kotlin Coroutines】](https://at-sushi.work/blog/35)

---

`RxJava`の`Lifecycle`の対応は[RxLifecycle](https://github.com/trello/RxLifecycle)等のサードパーティのツールを使うことで行うことが出来ます。

### DataBinding

`DataBinding`は`xml`から値を参照することで、コード量を削減することが出来ます。

`LiveData`は`DataBinding`に対応しています。

`Flow`は`StateFlow`を使うことで`DataBinding`で扱うことが出来ますが、まだ[Canary版のみ](https://androidstudio.googleblog.com/2021/01/android-studio-arctic-fox-canary-4.html)になっています。

`RxJava`は`DataBinding`に対応しておらず、[ObservableField](https://developer.android.com/reference/android/databinding/ObservableField)か`LiveData`に変換する必要があります。

### Javaからの利用
`LiveData`と`RxJava`は`Java`から利用が可能です。

`Flow`は`Kotlin`からのみ利用ができ、`Java`からは使うことは出来ません。　

### Null安全
`Flow`は`Kotlin`で書かれているため、完全にNull安全です。

また、`RxJava`もNull安全で扱えます。

`LiveData`はLintでチェックできるようになりましたが、完全にNull安全と言えるかというと、少し難しいところがありそうです。

### マルチプラットフォーム
`Flow`は`Kotlin Multiplatform`に対応しており、AndroidとiOSのコードを一部共通化することが可能です。

`RxJava`は`ReactiveX`に準拠した[RxSwift](https://github.com/ReactiveX/RxSwift)や[RxDart](https://github.com/ReactiveX/rxdart)が存在し、複数プラットフォームで似たような記述が可能です。

### 安定性
`Flow`はまだまだ成長途中のため、今後破壊的変更や大幅な機能追加も考えられます。

`RxJava`や`LiveData`はかなり安定してきていると考えられるでしょう。

### 複雑性
`RxJava`はオペレータの数が膨大で、かなり複雑に感じます。

`Flow`は`RxJava`と似ている部分も多いですが、一度のみ値を返す`suspend function`は非常にシンプルで、比較すると`RxJava`より洗練されてると言えるでしょう。

`LiveData`は複雑な機能は殆どないので、一番シンプルだと思います。

一方で、機能の豊富さという観点から見ると、逆の結果になるでしょう。

### 外部ツールの連携
`LiveData`は`Jetpack`の各種ライブラリと相性が良く、必要なことはほぼほぼできると思います。

`Flow`はJetpackライブラリ群でも力を入れて支援をしています。

まだまだ発展途上ですが、今後より使いやすくなっていくことでしょう。

`RxJava`は周辺ライブラリの開発も活発で、多くのツールが存在します。

一方で、Google公式によるサポートはあまり無いように感じます。

また、`Kotlin Coroutines`の発展とともに、最近は下火になっている印象があります。

### Jetpack Composeとの相性
`LiveData`、`Flow`、`RxJava`ともにJetpack ComposeのStateに変換可能なオペレータが用意されています。

どれを利用していても、Jetpack Composeは利用可能です。

* [LiveData.observeAsState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/livedata/package-summary)
* [Flow.collectAsState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#collectasstate)
* [Observable.subscribeAsState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/rxjava3/package-summary)

一方で、Coroutinesに対応した[rememberCoroutineScope](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remembercoroutinescope)や[LaunchedEffect](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#launchedeffect_1)等のAPIが存在し、若干Coroutinesに軍配が上がりそうです。

## 比較一覧
上記を表にすると、以下のようになるでしょう

　|LiveData|Flow|RxJava
:--|:--:|:--:|:--:
Lifecycle|◎|◯|◯
DataBinding|◎|◯|✕
Javaからの利用|◎|✕|◎
Null安全|△|◎|◎
マルチプラットフォーム|✕|◯|◯
安定性|◯|△|◯
複雑性|◎|◯|△
機能の豊富さ|△|◯|◎
外部ツールとの連携|◯|◯|◯
Jetpack Composeとの相性|◯|◎|◯


## 使い分け
様々な観点から3つを比較してきましたが、一長一短といったところで、今の所これが良い、これは悪い、みたいなところは無いと思います。

それぞれの長所、短所を理解した上で、自分のプロジェクトにあったツールを採用することが大事です。

強いて言うのであれば、やはり`Flow`は今後より発展が見込めるため、新規プロジェクトで採用したり、`LiveData`や`RxJava`から徐々に移行していくことは悪い選択肢ではないと思います。

データレイヤーでの取り扱いや、イベント通知等を含め、統一感のあるコードを書くことが可能になります。

一方で、α版でのみ提供されている機能があったり、今後大きな変更がある可能性を考えると、多少慎重になる必要があるでしょう。

また、個人的に`LiveData`のシンプルさは好きです。

シンプルなプロジェクトであれば、新規プロジェクトであっても`LiveData`を中心に組むと良いと思います。

`RxJava`は複数プラットフォームで似た書き方ができるという大きな特徴があります。

`ReactiveX`の思想でコーディングするためには、`RxJava`が必須です。

---

冒頭にも言いましたが、現段階において`Coroutines`に積極的に置き換える理由はないでしょう。

複数の書き方が入り交じるプロジェクトは、理解が困難になり、不具合も入り込みやすくなります。

引き続き`LiveData`、`RxJava`を使い続けることは、それもまた非常に良い選択です。

選択肢が多いと悩みがちですが、各々にとって一番使いやすいツールが見つかることを祈っています。

---
Kotlin Coroutinesの解説本をZennにて販売しています。より詳しく学びたい方は、こちらも合わせて確認してみて下さい。

[![](https://cdn.at-sushi.work/temp/zenn-coroutines-pr.png)](https://zenn.dev/at_sushi_at/books/edf63219adfc31)
[詳解 Kotlin Coroutines \[2021\] | Zenn](https://zenn.dev/at_sushi_at/books/edf63219adfc31)