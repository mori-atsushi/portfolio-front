---
title: 'Jetpack ComposeとKotlin Coroutinesを連携させる'
description: 'この記事は Android Advent Calendar 2021 の13日目の記事です。\nJetpack Composeは内部でもKotlin Coroutinesを多く使っており、非常に相性が良いです。\n今回はJetpack ComposeとKotlin Coroutinesを組み合わせて使ういくつかの方法について紹介します。'
pubDate: '2021-12-13T00:00:00.000Z'
ogpImage: '../../assets/2021-12-13-ogp.png'
---

この記事は [Android Advent Calendar 2021](https://qiita.com/advent-calendar/2021/android) の13日目の記事です。

Jetpack Composeは内部でもKotlin Coroutinesを多く使っており、非常に相性が良いです。

今回はJetpack  ComposeとKotlin Coroutinesを組み合わせて使ういくつかの方法について紹介します。

## collectAsState
Jetpack Composeでは、[State](https://developer.android.com/reference/kotlin/androidx/compose/runtime/State)の値を変化させることで画面更新をさせることができます。

ViewModel等で[StateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/)を使っている場合、[collectsState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#(kotlinx.coroutines.flow.StateFlow).collectAsState(kotlin.coroutines.CoroutineContext)) を使うことで`State`に変換することができ、Composeに反映させることができるようになります。

```kotlin
@Composable
fun Sample(
    viewModel: SampleViewModel = viewModel()
) {
    val count by viewModel.count.collectAsState()
    Text(text = count.toString())
}
```

`StateFlow`ではない[Flow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html)を`State`に直す際は、初期値が必要です。

```kotlin
@Composable
fun Sample(
    viewModel: SampleViewModel = viewModel()
) {
    val count by viewModel.count.collectAsState(initial = 0)
    Text(text = count.toString())
}
```

## LaunchedEffect
Composable関数内でsuspend functionを呼び出すには、[LaunchedEffect](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1)) を使うことで実現できます。

`LaunchedEffect` は表示時にCoroutinesが起動され、非表示になったタイミングでキャンセルが行われます。

また、指定したkeyが変更になった際には一度キャンセルされ、新たにCoroutinesが起動されます。

例えば、snackbarを表示する[SnackbarHostState](https://developer.android.com/reference/kotlin/androidx/compose/material/SnackbarHostState)の[showSnackbar](https://developer.android.com/reference/kotlin/androidx/compose/material/SnackbarHostState#showSnackbar(kotlin.String,kotlin.String,androidx.compose.material.SnackbarDuration)) はsuspend functionになっており、Coroutines内で呼び出す必要があります。

以下は、引数のerrorが変更されたタイミングでsnackbarを表示するサンプルです。

```kotlin
@Composable
fun LaunchedEffectSample(
    error: Throwable?
) {
    val snackbarHostState = remember { SnackbarHostState() }
    LaunchedEffect(error) {
        error?.let {
            snackbarHostState.showSnackbar(it.message.orEmpty())
        }
    }
    SnackbarHost(hostState = snackbarHostState)
}
```

表示時に一度のみ起動したい場合は、`key`に`Unit`や`true`等、変更されないものを指定することで実現できます。

```kotlin
@Composable
fun LaunchedEffectUnitSample() {
    val snackbarHostState = remember { SnackbarHostState() }
    LaunchedEffect(Unit) {
        snackbarHostState.showSnackbar("Welcome!")
    }
    SnackbarHost(hostState = snackbarHostState)
}
```

`LaunchedEffect` 内で参照されている変数は基本keyに指定しておくことで、古い値を参照し続けることを防ぐことができます。

一方で、 `SnackbarHostState` 等、絶対に変更されない値はkeyに指定しなくて問題ありません。

ViewModelから`Flow`や[Channel](https://kotlinlang.org/docs/channels.html)でイベントを送っている場合も、`LaunchedEffect`を使うことで受け取ることができます。

```kotlin
@Composable
fun LaunchedEffectFlowSample(
    viewModel: SampleViewModel = viewModel()
) {
    val snackbarHostState = remember { SnackbarHostState() }
    LaunchedEffect(viewModel.message) {
        viewModel.message.collect {
            snackbarHostState.showSnackbar(it)
        }
    }
    SnackbarHost(hostState = snackbarHostState)
}
```

## rememberCoroutineScope
`LaunchedEffect`以外に`CoroutinesScope`を取得する方法として、[rememberCoroutineScope](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0)) があります。

以下はクリック時にsnackbarを表示する例です。

```kotlin
@Composable
fun RememberCoroutineScopeSample() {
    val scope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }
    Button(
        onClick = {
            scope.launch {
                snackbarHostState.showSnackbar("Hello!")
            }
        }
    ) {
        Text(text = "Button")
    }
    SnackbarHost(hostState = snackbarHostState)
}
```

`rememberCoroutineScope` で取得した `CoroutinesScope` も非表示時にキャンセルされるため、安全に扱うことができます。

## produceState
`Flow`から`State`への変換は`collectAsState`が利用できますが、suspend functionから`State`への変換は[produceState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1)) を使います。

`LaunchedEffect`と同様に表示時に起動され、`key`をしている場合は`key`の変更に合わせて再起動されます。

```kotlin
@Composable
fun ProduceStateSample(
    api: Api
) {
    val state by produceState(initialValue = "loading") {
        value = try {
            api.call()
            "successed"
        } catch (e: Throwable) {
            "failed"
        }
    }
    Text(text = state)
}
```

`collectAsState`の実装にも`produceState`が使われていました。

今回は1例として上げましたが、実際はComposable関数から直接APIを叩くことは少ないと思うので、あまり使うことが無いかもしれません。

## snapshotFlow
反対に、`State`から`Flow`に変換するには[snapshotFlow](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0)) を使います。

例えば、以下のようにスクロール位置をFlowで監視することができます。

```kotlin
@Composable
fun SnapshotFlowSample(
    viewModel: SampleViewModel
) {
    val listState = rememberLazyListState()

    LaunchedEffect(listState) {
        snapshotFlow { listState.firstVisibleItemIndex }
            .filter { it == 0 }
            .collect {
                viewModel.changeIsTop(it)
            }
    }

    LazyColumn(state = listState) {
        // ...
    }
}
```

`Flow`の作成や`Flow`のオペレータによる変換は、Composable関数内で呼び出すとRecompose毎に再生成されてしまうので、`remember`や`LaunchedEffect`内でのみ行ってください。

```kotlin
@Composable
fun SnapshotFlowSamples() {
    // Recompose毎に新規flowが作られてしまうため行わない
    val flow = snapshotFlow { /* ... */ }

    // これはOK
    val flow = remember { snapshotFlow { /* ... */ } }

    // これもRecompose毎にflowが再生成されてしまう
    val transformed = flow.map { it.toString() }

    // これはOK
    val transformed = remember(flow) {
        flow.map { it.toString() }
    }

    // これもOK
    LaunchedEffect(flow) {
        flow.map { it.toString() }
            .collect { /* ... */ } }
    }
}
```

`snapshotFlow` で監視できるのは `State` なので、Composable関数の引数をFlowに変換することはできません。

```kotlin
@Composable
fun SnapshotFlowSample(
    count: Int
) {
    LaunchedEffect(Unit) {
        snapshotFlow { count } // 動作しない！
            .collect {
                // ...
            }
    }
}
```

`MutableStateFlow`を[remember](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)) した後に[SideEffect](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#SideEffect(kotlin.Function0)) で更新することでFlow化することができます。

```kotlin
@Composable
fun MutableStateFlowSample(
    count: Int
) {
    val flow = remember { MutableStateFlow(count) }
    SideEffect {
        flow.value = count
    }
    LaunchedEffect(Unit) {
        flow.collect {
            // ...
        }
    }
}
```

あまり利用ケースは多くないかも知れませんが、以下のようなComposable関数を用意しても良いでしょう。

```kotlin
@Composable
fun <T> rememberFlow(value: T): StateFlow<T> {
    val flow = remember {
        MutableStateFlow(value)
    }
    SideEffect {
        flow.value = value
    }
    return flow
}
```

## Lifecycleを考慮する
上記の方法では、いずれもLifecycleを考慮していないため、バックグラウンドにいるときも動作し続けます。

[repeatOnLifecycle](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?hl=id#repeatonlifecycle_1)を使うことでLifecycleに従って動作させることが可能になります。

[LifecycleOwner](https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner)は[LocalLifecycleOwner](https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalLifecycleOwner()) から取得することができます。

`LaunchedEffect` で`onStart`から`onStop`までを動作させたい場合は、以下のように記述することで実現が可能です。

```kotlin
@Composable
fun Sample(
    viewModel: SampleViewModel = viewModel()
) {
    val lifecycleOwner = LocalLifecycleOwner.current
    val snackbarHostState = remember { SnackbarHostState() }
    LaunchedEffect(viewModel.message) {
        lifecycleOwner.repeatOnLifecycle(state) {
            viewModel.message.collect {
                snackbarHostState.showSnackbar(it)
            }
        }
    }
    SnackbarHost(hostState = snackbarHostState)
}
```

以下のようなComposable関数を用意しておくと便利かもしれません。

```kotlin
@Composable
fun <T> CollectInLifecycle(
    flow: Flow<T>,
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    state: Lifecycle.State = Lifecycle.State.STARTED,
    f: suspend CoroutineScope.(T) -> Unit
) {
    LaunchedEffect(flow) {
        lifecycleOwner.repeatOnLifecycle(state) {
            flow.collect {
                f(it)
            }
        }
    }
}
```

`collectAsState`を行うケースも、ほとんどの場合は`onStart`から`onStop`の間でのみ行えば良いでしょう。

こちらも、以下のようにLifecycle指定で`collect`できるようにしても良さそうです。

```kotlin
@Composable
@Suppress("StateFlowValueCalledInComposition")
fun <T> StateFlow<T>.collectAsStateInLifecycle(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    state: Lifecycle.State = Lifecycle.State.STARTED,
    context: CoroutineContext = EmptyCoroutineContext
): State<T> {
    return produceState(value, this, lifecycleOwner, state, context) {
        lifecycleOwner.repeatOnLifecycle(state) {
            if (context == EmptyCoroutineContext) {
                collect { value = it }
            } else withContext(context) {
                collect { value = it }
            }
        }
    }
}
```

`repeatOnLifecycle` については以下の記事も参考にしてください。

* [launchWhenXXとrepeatOnLifecycleの違い【Android / Kotlin Coroutines】](https://at-sushi.work/blog/35/)


## まとめ
Jetpack ComposeとKotlin Coroutinesを組み合わせる方法について紹介をしてきました。

ActivityやFragment、Android Viewと比べて、格段にCoroutinesを呼び出しやすくなっていると思います。

ライブラリ内の処理や標準コンポーネントの実装を見ることで、より良い使い方を学ぶことができます。

一方で、関心の分離の観点から、UIを表現するComposable関数にドメインロジックを含ませないように心がけるべきでしょう。

また、Lifecycleをどれくらい考慮すべきかについても議論があると思います。

最後に `collectAsStateInLifecycle` を紹介しましたが、公式で提供されている `collectAsState` を利用したほうがわかりやすいケースも多いと思います。

状況に合わせて選択してもらえると幸いです。

## 参考文献
* [Compose における副作用  |  Jetpack Compose  |  Android Developers](https://developer.android.com/jetpack/compose/side-effects?hl=ja)
* [Comparing use of LiveData and StateFlow in a Jetpack Compose project | John O’Reilly](https://johnoreilly.dev/posts/jetpack-compose-stateflow-livedata/)