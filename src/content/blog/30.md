---
title: '【Kotlin】suspend functionとテストの書き方'
description: 'この記事は Kotlin Advent Calendar 2020の15日目の記事です。\n非同期処理を書く際に、kotlin coroutinesは使いやすく、非常に強力です。\n一方で、単体テスト等を書くのには一定のハードルがあります。\n今回は、suspend functionをテストしたり、モックする方法について紹介します。'
pubDate: '2020-12-15T10:00:00.000Z'
updatedDate: '2021-01-31T06:00:00.000Z'
ogpImage: '../../assets/2020-12-15-ogp.png'
---

この記事は [Kotlin Advent Calendar 2020](https://qiita.com/advent-calendar/2020/kotlin) の15日目の記事です。

非同期処理を書く際に、kotlin coroutinesは使いやすく、非常に強力です。

一方で、単体テスト等を書くのには一定のハードルがあります。

今回は、suspend functionをテストしたり、モックする方法について紹介します。

## 時間のかかるsuspend functionをテストする
例えば、以下のような実行に10秒かかるsuspend functionがあったとします。
```kotlin
suspend fun sample(): Int {
    delay(10_000)
    return 10
}
```

これをテストする際に、[runBlocking](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html)等を使ってしまうと、テストの実行に10秒かかってしまいます。
```kotlin
@Test
fun test() {
    val actual = runBlocking {
        sample()
    }
    assertThat(actual).isEqualTo(10)
}
```

こういったテストをたくさん書いていくと、テストの実行に時間がかかるようになってしまうため、テストは即座に完了することが望ましいとされています。

そのため、kotlin coroutinesには[kotlinx-coroutines-test](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/index.html)というテストツールが用意されています。

このように依存関係を追加してください。

versionは使っているkotlin coroutinesのversionと合わせてください。
```groovy
dependencies {
    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:{version}'
}
```

そうすると、[runBlockingTest](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html)が利用できるようになり、テストを即座に実行することができるようになります。
```kotlin
@Test
fun test() {
    runBlockingTest {
        val actual = sample()
        assertThat(actual).isEqualTo(10)
    }
}
```

## 中でcoroutinesをlaunchするメソッドをテストする
例えば、このように `sample` メソッドを呼び出した10秒後に `isCalled` の値を書き換えるクラスが合ったとします。
```kotlin
class Sample {
    private val dispatcher = Dispatchers.Main.immediate
    private val scope = CoroutineScope(dispatcher)

    var isCalled: Boolean = false

    fun sample() {
        scope.launch {
            delay(10_000)
            isCalled = true
        }
    }
}
```

このクラスをテストするためには、[setMain](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/kotlinx.coroutines.-dispatchers/set-main.html)をつかって`Dispatchers.Main`を[TestCoroutineDispatcher](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/)差し替えることで、時間をかけずに正しくテストすることができます。

[DelayController.advanceTimeBy](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html)を使うことで、時間を操作することができます。
```kotlin
@ExperimentalCoroutinesApi
class SampleTest {
    private val dispatcher = TestCoroutineDispatcher()

    @Before
    fun setup() {
        Dispatchers.setMain(dispatcher)
    }

    @After
    fun clear() {
        Dispatchers.resetMain()
    }

    @Test
    fun test() {
        val sample = Sample()
        sample.sample()
        assertThat(sample.isCalled).isFalse()
        dispatcher.advanceTimeBy(10_000)
        assertThat(sample.isCalled).isTrue()
    }
}
```

[DelayController.advanceUntilIdle](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-until-idle.html)を使うことで、保留中のタスクがすべて終わるまで待機してくれるので、こちらの書き方でも良いでしょう。
```kotlin
@Test
fun test() {
    val sample = Sample()
    sample.sample()
    assertThat(sample.isCalled).isFalse()
    dispatcher.advanceUntilIdle()
    assertThat(sample.isCalled).isTrue()
}
```

Androidにおける[ViewModelScope](https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope)も同じ方法で差し替えることができます。

以下のようなViewModelも上記のテストでカバーできます。
```kotlin
class SampleViewModel : ViewModel() {
    var isCalled: Boolean = false

    fun sample() {
        viewModelScope.launch {
            delay(10_000)
            isCalled = true
        }
    }
}
```

### Dispatchers.Default等を使ってる場合
以下のように、`Dispatchers.Main` 以外のcontextで起動してる場合、上記のテストは動きません。

```kotlin
class Sample {
    private val scope = CoroutineScope(EmptyCoroutineContext)

    var isCalled: Boolean = false

    fun sample() {
        scope.launch(Dispatchers.Default) {
            delay(10_000)
            isCalled = true
        }
    }
}
```

こういった場合は、現状contextをDIできるようにしておく必要がありそうです。
```kotlin
class Sample(
    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default
) {
    private val scope = CoroutineScope(EmptyCoroutineContext)

    var isCalled: Boolean = false

    fun sample() {
        scope.launch(defaultDispatcher) {
            delay(10_000)
            isCalled = true
        }
    }
}
```
```kotlin
@Test
fun test() {
    val sample = Sample(dispatcher)
    sample.sample()
    assertThat(sample.isCalled).isFalse()
    dispatcher.advanceTimeBy(10_000)
    assertThat(sample.isCalled).isTrue()
}
```

## suspend functionをモックする
[mockk](https://github.com/mockk/mockk)を使うことで、suspend functionをモックすることができます。
```groovy
dependencies {
    testImplementation "io.mockk:mockk:{version}"
}
```

例えば以下のような、`DataSource` から取得した値に `+1` するクラスが合ったとします。
```kotlin
class Sample(
    private val dataSource: DataSource
) {
    suspend fun sample(): Int {
        return dataSource.getData() + 1
    }
}

interface DataSource {
    suspend fun getData(): Int
}
```

この `DataSource` はモックしつつ、Sampleのテストを書きたい場合、`coEvery`を使ってこのように書くことができます。

```kotlin
@Test
fun test() {
    runBlockingTest {
        val dataSource: DataSource = mockk()

        // `dataSource.getData()` の返り値を定義
        coEvery {
            dataSource.getData()
        } returns 10

        val sample = Sample(dataSource)
        val actual = sample.sample()
        assertThat(actual).isEqualTo(11)
    }
}
```

`coVerify` を使って、メソッドが呼び出されたかのテストをすることもできます。
```kotlin
@Test
fun test() {
    runBlockingTest {
        val dataSource: DataSource = mockk()

        coEvery {
            dataSource.getData()
        } returns 10

        val sample = Sample(dataSource)
        sample.sample()

        // 1回 `dataSource.getData()` が呼び出されたことを確認
        coVerify(exactly = 1) {
            dataSource.getData()
        }
    }
}
```

### 時間がかかるsuspend functionを定義する
以下のような1秒たったらtimeoutし、-1を返すメソッドをテストしたいとします。
```kotlin
class Sample(
    private val dataSource: DataSource
) {
    suspend fun sample(): Int {
        return withTimeoutOrNull(1_000) {
            dataSource.getData() + 1
        } ?: -1
    }
}
```

以下のように、`coAnswers` を使うことで時間のかかるsuspend functionを定義することができます。
```kotlin
@Test
fun test() {
    runBlockingTest {
        val dataSource: DataSource = mockk()

        // 5秒後に値を返すよう定義
        coEvery {
            dataSource.getData()
        } coAnswers {
            delay(5_000)
            10
        }

        val sample = Sample(dataSource)
        
        val actual = sample.sample()
        assertThat(actual).isEqualTo(-1)
    }
}
```

以下のように[DelayController.currentTime](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/current-time.html)を使うことで、かかった時間を測定することもできます。
```kotlin
@Test
fun test() {
    runBlockingTest {
        val dataSource: DataSource = mockk()

        // 5秒後に値を返すよう定義
        coEvery {
            dataSource.getData()
        } coAnswers {
            delay(5_000)
            10
        }

        val sample = Sample(dataSource)
        val startTime = currentTime
        sample.sample()
        val endTime = currentTime

        // 1秒しか経ってないこと確認
        assertThat(endTime - startTime).isEqualTo(1_000)
    }
}
```


## まとめ
今回はsuspend functionに関するテストの書き方を紹介しました。

本来時間がかかる処理であっても、テストでは必ず即座に実行されるよう工夫することで、テストにかかる時間を短縮することができます。

また、以前flowのテストについて紹介しています。よかったら参考にしてみてください。

[kotlin coroutines flowのテストを快適に書く](https://at-sushi.work/blog/20)

非同期処理は難しく、またそれに対するテストも複雑になりがちです。

担保したいことは何なのかを意識しつつ、適切な粒度で書いていくことが大事だと考えています。

**- 2021/01/31追記- **

Kotlin Coroutinesの解説本をZennにて販売しています。より詳しく学びたい方は、こちらも合わせて確認してみて下さい。

[![](../../assets/zenn-coroutines-pr.png)](https://zenn.dev/at_sushi_at/books/edf63219adfc31)
[詳解 Kotlin Coroutines \[2021\] | Zenn](https://zenn.dev/at_sushi_at/books/edf63219adfc31)