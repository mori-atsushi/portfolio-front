---
title: 'LiveDataからCoroutines Flowへ移行する'
description: '以前「LiveData vs Flow vs RxJava」という記事で紹介したとおり、LiveDataは非常にシンプルで、現在でもベストプラクティスであることは間違いないでしょう。\n一方で、既に多くの箇所でCoroutinesを導入していたり、Coroutinesが使いやすいと感じている場合、LiveDataからCoroutinesのFlowに移行することも選択肢の1つでしょう。\nCoroutinesはLiveDataより複雑で、様々なオプションを提供してくれているため、利用に戸惑うこともあると思います。\n今回は、LiveDataが利用されていたようなケースでCoroutines Flowを使う場合どうしたらいいのか、細かい差分についても紹介をしていきます。'
pubDate: '2021-10-31T06:00:00.000Z'
ogpImage: 'https://cdn.at-sushi.work/temp/2021-10-31-ogp.png'
---

以前「[LiveData vs Flow vs RxJava](https://at-sushi.work/blog/34)」という記事で紹介したとおり、LiveDataは非常にシンプルで、現在でもベストプラクティスであることは間違いないでしょう。

一方で、既に多くの箇所でCoroutinesを導入していたり、Coroutinesが使いやすいと感じている場合、LiveDataからCoroutinesのFlowに移行することも選択肢の1つでしょう。

CoroutinesはLiveDataより複雑で、様々なオプションを提供してくれているため、利用に戸惑うこともあると思います。

今回は、LiveDataが利用されていたようなケースでCoroutines Flowを使う場合どうしたらいいのか、細かい差分についても紹介をしていきます。

## LiveDataとStateFlow
[LiveData](https://developer.android.com/reference/androidx/lifecycle/LiveData)を置き換えるのであれば、[StateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/)を使うのが良いでしょう。

`LiveData`には`StateFlow`、[MutableLiveData](https://developer.android.com/reference/androidx/lifecycle/MutableLiveData)には[MutableStateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/index.html)が対応します。

```diff
- private val mutableData = MutableLiveData("")
- val data: LiveData<String> = mutableData
+ private val mutableData = MutableStateFlow("")
+ val data: StateFlow<String> = mutableData
```

異なる点としては、StateFlowでは初期値が必須になります。

初期値が存在しないときは、nullableにしてnullを指定するのが良いでしょう。

```diff
- private val mutableData = MutableLiveData()
- val data: LiveData<String> = mutableData
+ private val mutableData = MutableStateFlow<String?>(null)
+ val data: StateFlow<String?> = mutableData
```

LiveDataにはUIスレッド用の`setValue`とバックグランドスレッド用の`postValue`がありますが、StateFlowはどのスレッドでも`value`を使って更新することが可能です。

```kotlin
val mutableData = MutableStateFlow<String>("initial")
mutableData.value = "updated"
```

## DataBinding
[Android Studio Arctic Fox](https://developer.android.com/studio/releases#arctic-fox)より、StateFlowで[DataBindingが使えるように](https://developer.android.com/studio/releases#state-flow-data-binding)なりました。

そのため、xmlはLiveDataと同じようにそのまま使えます。

```xml
<TextView
    android:id="@+id/textView"
    android:text="@{viewmodel.data}" />
```

## Lifecycleでobserveする
ActivityやFragmentから`LiveData`を監視するには、`observe`関数を使います。

`lifecycleOwner` (ここでは`Activity`自体)を渡すことで`onStart`から`onStop`までの間だけ監視してくれ、安全かつ効率的にViewを更新することが出来ます。

```kotlin
class SampleActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel.data.observe(this) {
            binding.textView.text = it
        }
    }
}
```

`Flow`を使う場合はいくつか気をつけるべき点があります。

ここではLifecycle KTXの[2.4.0](https://developer.android.com/jetpack/androidx/releases/lifecycle#2.4.0)以降を使います。

```kotlin
implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.4.0")
```

`lifecycleScope`を使った後に[repeatOnLifecycle](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?hl=id#repeatonlifecycle_1)で`Lifecycle.State.STARTED`を指定することで、LiveDataと同じように`onStart`から`onStop`まで監視してくれます。

```kotlin
class SampleActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.data.collect {
                    binding.textView.text = it
                }
            }
        }
    }
}
```

以下のような拡張関数を作っておくと便利かもしれません。

```kotlin
fun <T> Flow<T>.collectIn(
    lifecycleOwner: LifecycleOwner,
    observer: (T) -> Unit
) {
    lifecycleOwner.lifecycleScope.launch {
        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
            this@collectIn.collect {
                observer(it)
            }
        }
    }
}
```
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
   super.onCreate(savedInstanceState)

    viewModel.data.collectIn(this) {
        binding.textView.text = it
    }
}
```

### 気をつけるべき書き方① : `lifecycleScope.launch`の中で直接`collect`する

FlowをLifecycleから監視する際に、いくつか間違えやすい書き方があります。

1つ目は、`lifecycleScope.launch`の中で直接`collect`するものです。

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    lifecycleScope.launch {
        viewModel.data.collect {
            binding.textView.text = it
        }
    }
}
```

この書き方を行うと、一見期待しているように動きますが、バックグランドに移動した場合等`onStop`になっても動き続け、不要にUI更新が行われる可能性があります。

検証のため、1秒に1ずつインクリメントして検証してみます。

```kotlin
class TestViewModel : ViewModel() {
    private val _state = MutableStateFlow(0)
    val state: StateFlow<Int> = _state

    init {
        viewModelScope.launch {
            while (true) {
                delay(1000)
                _state.value = _state.value + 1
            }
        }
    }
}
```
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    lifecycleScope.launch {
        viewModel.state.collect {
            Log.d("TestActivity", "launch:$it")
        }
    }
    lifecycleScope.launch {
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            viewModel.state.collect {
                Log.d("TestActivity", "launch+repeatOnLifecycle:$it")
            }
        }
    }
}
```

この結果は以下のようになります。

```text
D/TestActivity: launch:0
D/TestActivity: launch+repeatOnLifecycle:0
D/TestActivity: launch:1
D/TestActivity: launch+repeatOnLifecycle:1
D/TestActivity: launch:2
D/TestActivity: launch+repeatOnLifecycle:2
D/TestActivity: launch:3
D/TestActivity: launch+repeatOnLifecycle:3
// バックグランドへ（onStop）
D/TestActivity: launch:4
D/TestActivity: launch:5
D/TestActivity: launch:6
D/TestActivity: launch:7
// フォアグラウンドへ（onStart）
D/TestActivity: launch+repeatOnLifecycle:7
D/TestActivity: launch:8
D/TestActivity: launch+repeatOnLifecycle:8
D/TestActivity: launch:9
D/TestActivity: launch+repeatOnLifecycle:9
D/TestActivity: launch:10
D/TestActivity: launch+repeatOnLifecycle:10
```

`launch`のみの場合はバックグラウンド時も動作し続けますが、`repeatOnLifecycle` と組み合わせたときにフォアグラウンド時のみに更新を制限できることが分かると思います。

また`StateFlow`を使った場合、フォアグラウンドになったタイミングで最新の値が反映されるため、古い情報が表示される心配もありません。

通常のケースであれば、`repeatOnLifecycle` を使うことで不要な画面更新を抑えることが出来るでしょう。

### 気をつけるべき書き方②: `launchWhenStarted`で`Flow`を扱う

`LifecycleCoroutineScope`には[launchWhenStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope#launchwhenstarted)という`onStart`から`onStop`まで動作する`launch`メソッドが存在しますが、これを`Flow`に対して利用するのは推奨されていません。

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    lifecycleScope.launchWhenStarted {
        viewModel.data.collect {
            binding.textView.text = it
        }
    }
}
```

`repeatOnLifecycle` を利用した場合、 `onStop` になったときにCoroutinesがキャンセルされ、リソースが開放されますが、`launchWhenStarted`では一時停止の状態になるだけでリソースが開放されません。

`StateFlow`であまり大きな問題になることはありませんが、`SharedFlow`や`Channel`等、`buffer`を持つものは`buffer`がつまる危険性もあります。

[公式ドキュメント](https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope#launchwhenstarted)にも以下のように書かれ、将来的に削除される計画があります。

> Caution: This API is not recommended to use as it can lead to wasted resources in some cases. Please, use the Lifecycle.repeatOnLifecycle API instead. This API will be removed in a future release.

> 注意：このAPIは、場合によってはリソースの浪費につながる可能性があるため、使用をお勧めしません。代わりにLifecycle.repeatOnLifecycle APIを使用してください。このAPIは、将来のリリースで削除される予定です。

今後は `repeatOnLifecycle`を使うようにしましょう。

## map / switchMap
オペレーター系の移行についても見ていきましょう。

基本的にはLiveDataよりFlowのほうがオペレータが多いため、自由度が増します。

LiveDataの[map](https://developer.android.google.cn/reference/androidx/lifecycle/TransformationsKt?hl=ja#(androidx.lifecycle.LiveData).map(kotlin.Function1))はFlowでもそのまま[map](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html)が対応します。

```diff
- val data1 = MutableLiveData(0)
+ val data1 = MutableStateFlow(0)
val data2 = data1.map { it * 2 }
```

LiveDataの[switchMap](https://developer.android.google.cn/reference/androidx/lifecycle/TransformationsKt?hl=ja#(androidx.lifecycle.LiveData).switchMap(kotlin.Function1))には[flatMapLatest](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html)が対応しています。

このメソッドはまだ[ExperimentalCoroutinesApi](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/index.html)となっており、変更される可能性があります。

```diff
- val flag = MutableLiveData(false)
- val data1 = MutableLiveData(0)
- val data2 = MutableLiveData(1)
- val data3 = flag.switchMap { if (it) data1 else data2 }
+ val flag = MutableStateFlow(false)
+ val data1 = MutableStateFlow(0)
+ val data2 = MutableStateFlow(1)
+ val data3 = flag.flatMapLatest { if (it) data1 else data2 }
```

### Cold Streamに気をつけて

`map`も`flatMapLatest`も`StateFlow`に対して利用すると`Flow`に変換され、cold streamとして扱われます。

そのため、`map`した`Flow`を複数箇所で`collect`すると、`collect`の回数分`map`が呼ばれることになります。

```kotlin
class TestViewModel : ViewModel() {
    private val data1 = MutableStateFlow(0)
    val data2 = data1.map {
        Log.d("TestViewModel", "map:$it")
        it * 2
    }

    init {
        viewModelScope.launch {
            while (true) {
                delay(1000)
                data1.value = data1.value + 1
            }
        }
    }
}
```
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    lifecycleScope.launch {
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            viewModel.data2.collect {
                Log.d("TestActivity", "collect1:$it")
            }
        }
    }
    lifecycleScope.launch {
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            viewModel.data2.collect {
                Log.d("TestActivity", "collect1:$it")
            }
        }
    }
}
```

1つのデータにつき、`map`が2回呼ばれていることが確認できます。

```text
D/TestViewModel: map:0
D/TestActivity: collect1:0
D/TestViewModel: map:0
D/TestActivity: collect2:0
D/TestViewModel: map:1
D/TestActivity: collect1:2
D/TestViewModel: map:1
D/TestActivity: collect2:2
D/TestViewModel: map:2
D/TestActivity: collect1:4
D/TestViewModel: map:2
D/TestActivity: collect2:4
```

LiveDataの`map`は値が共有されるため、`map`は1つのデータにつき一度のみ実行されます。

LiveDataのHot, Coldについては以下の記事で詳しく説明しています。

* [LiveDataのHot, Coldって意識できている？](https://at-sushi.work/blog/10)

また、`DataBinding`は`StateFlow`のみ対応しており、`Flow`は直接利用出来ないことにも注意が必要です。

Flowでは、[stateIn](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html)を使うことで`StateFlow`に変換することができ、値も共有されるようになります。

`started`には[SharingStarted.WhileSubscribed()](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-companion/-while-subscribed.html)を指定することで、1つ以上`collect`されてるときにのみ動作するようになり、これでLiveDataと同じように動きます。

```diff
val data2 = data1.map {
    Log.d("TestViewModel", "map:$it")
    it * 2
- }
+ }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(), 0)
```
```text
D/TestActivity: collect1:0
D/TestViewModel: map:0
D/TestActivity: collect2:0
D/TestViewModel: map:1
D/TestActivity: collect1:2
D/TestActivity: collect2:2
D/TestViewModel: map:2
D/TestActivity: collect1:4
D/TestActivity: collect2:4
```

## distinctUntilChanged
`LiveData`には[distinctUntilChanged](https://developer.android.google.cn/reference/androidx/lifecycle/TransformationsKt?hl=ja#(androidx.lifecycle.LiveData).distinctUntilChanged())という値が変更されたタイミングのみ出力するというオペレータがあります。

`StateFlow`は同じ値は連続して流さないようになっているので、デフォルトで`distinctUntilChanged`が行われている状態になります。

`LiveData`を使うようなケースであれば、同じ値を連続して流す必要はないと思いますが、そのような要求があれば[SharedFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/)を使うのが良いでしょう。

`replay`に1、`onBufferOverflow`に[BufferOverflow.DROP_OLDEST](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-buffer-overflow/-d-r-o-p_-o-l-d-e-s-t/index.html)を指定することで、`LiveData`と同じく再`collect`時に最後の値を受け取れるようになります。

`value`の代わりに`emit`もしくは`tryEmit`を利用する必要があります。

```kotlin
val flow = MutableSharedFlow<Int>(
    replay = 1,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
).apply {
    tryEmit(0)
}
```

一方、イベントとして扱いたいときは[Channel](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html)を使うのが良いでしょう。

* [kotlin coroutinesでViewModelからViewにイベント通知したい](https://at-sushi.work/blog/28)

## MediatorLiveData
`LiveData`には高度な変換を行うことが出来る[MediatorLiveData](https://developer.android.com/reference/androidx/lifecycle/MediatorLiveData)が用意されています。

```kotlin
val data1 = MutableLiveData(0)
val data2 = MutableLiveData(1)
val merged = MediatorLiveData<Int>().apply {
    addSource(data1) {
        value = it
    }
    addSource(data2) {
        value = it
    }
}
```

`Flow`では[channelFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html)を使うことでほぼ同じ操作を行うことが出来ます。

ここでも`stateIn`を使うことでリソースの共通化が出来ます。

```kotlin
val data1 = MutableStateFlow(0)
val data2 = MutableStateFlow(1)
val merged = channelFlow {
    launch {
        data1.collect {
            send(it)
        }
    }
    launch {
        data2.collect {
            send(it)
        }
    }
}.stateIn(viewModelScope, SharingStarted.WhileSubscribed(), 0)
```

`Flow`では多くのオペレータが用意されているため、より適したoperatorがあるかも知れません。

上記の例では[merge](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html)で同じ処理が簡潔に書けます。

```kotlin
val data1 = MutableStateFlow(0)
val data2 = MutableStateFlow(1)
val latest: StateFlow<Int?> = merge(data1, data2)
    .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), 0)
```

[combine](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html)や[filter](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html)もよく使うオペレータでしょう。

## まとめ
今回は`LiveData`の挙動を`Flow`で再現する方法について紹介しました。

`Flow`は多くのオプションを持つため、`LiveData`の挙動をほぼ再現することが可能な一方、気をつけるべき点もいくつかあることがわかりました。

今回は`LiveData`の挙動を再現することに重きを置きましたが、無理に`LiveData`の動作に合わせようとせず、`Flow`のデフォルトの挙動で扱うほうがわかりやすいケースもありそうです。

---

Kotlin Coroutinesの解説本をZennにて販売しています。より詳しく学びたい方は、こちらも合わせて確認してみて下さい。

[![](https://cdn.at-sushi.work/temp/zenn-coroutines-pr.png)](https://zenn.dev/at_sushi_at/books/edf63219adfc31)
[詳解 Kotlin Coroutines \[2021\] | Zenn](https://zenn.dev/at_sushi_at/books/edf63219adfc31)

