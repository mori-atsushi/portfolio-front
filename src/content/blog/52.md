---
title: 'Layout Composableを使って複雑なレイアウトを組む【Jetpack Compose】'
description: 'この記事はAndroid Advent Calendar 2022の4日目の記事です。\nJetpack Composeで複雑なレイアウトを組むのに、Box, Row, Columnだけでは表現できずに困ったときはありませんか？\nもしかしたらLayout Composableを使うことで実現できるかもしれません。\nLayout Composableはかなり自由度高くレイアウトを組める一方、複雑で敬遠しがちです。\n今回は例をもとにLayout Composableの使い方について紹介します。'
pubDate: '2022-12-04T00:00:00.000Z'
ogpImage: 'https://cdn.at-sushi.work/temp/2022-12-04-ogp.png'
---

この記事は[Android Advent Calendar 2022](https://qiita.com/advent-calendar/2022/android)の4日目の記事です。

Jetpack Composeで複雑なレイアウトを組むのに、Box, Row, Columnだけでは表現できずに困ったときはありませんか？

もしかしたらLayout Composableを使うことで実現できるかもしれません。

Layout Composableはかなり自由度高くレイアウトを組める一方、複雑で敬遠しがちです。

今回は例をもとにLayout Composableの使い方について紹介します。

## タイトルを中央に表示したい
例えば、以下のようにタイトルを中央に表示し、左にボタンを配置するレイアウトを考えます。

![](https://cdn.at-sushi.work/temp/2022-12-04-1.png)

以下のように`Box`を使って配置すると、タイトルが長いときにボタンに被ってしまいます。

```kotlin
@Composable
fun UseBox() {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
    ) {
        Text(
            modifier = Modifier.align(Alignment.Center),
            text = "Title Title Title Title Title Title Title Title",
            overflow = TextOverflow.Ellipsis,
            maxLines = 1
        )
        TextButton(
            modifier = Modifier.align(Alignment.CenterEnd),
            onClick = { /* ... */ }
        ) {
            Text(text = "Button")
        }
    }
}

```

![](https://cdn.at-sushi.work/temp/2022-12-04-2.png)

`Row`を使って実装すると、タイトルが左に寄ってしまいます。

```kotlin
@Composable
fun UseColumn() {
    Row(
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Box(
            modifier = Modifier.weight(1F),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = "Title",
                overflow = TextOverflow.Ellipsis,
                maxLines = 1
            )
        }
        TextButton(onClick = { /* ... */ }) {
            Text(text = "Button")
        }
    }
}
```

![](https://cdn.at-sushi.work/temp/2022-12-04-3.png)

## Layout Composableを使う
こういうときに利用できるのが [Layout Composable](https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/package-summary#Layout(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.ui.layout.MeasurePolicy)) です。

Layout Composableは以下の3ステップを実装することで、子Composableを好きな位置に配置できます。([参考](https://developer.android.com/jetpack/compose/layouts/custom))

1. すべての子を測定する
2. ノード自体のサイズを決定する
3. 子を配置する

上記の例で説明していきます。

### 1. すべての子を測定する

まず最初に、`content`に表示するComposableを指定します。

```kotlin
@Composable
fun UseLayout() {
    Layout(
        modifier = Modifier.padding(16.dp),
        content = {
            Text(
                text = "Title",
                overflow = TextOverflow.Ellipsis,
                maxLines = 1
            )
            TextButton(onClick = { /* ... */ }) {
                Text(text = "Button")
            }
        },
        measurePolicy = { measurables, constraints ->
            /* ... */
        }
    )
}
```

次に、`MeasurePolicy`を実装していきます。

```kotlin
fun interface MeasurePolicy {
    fun MeasureScope.measure(
        measurables: List<Measurable>,
        constraints: Constraints
    ): MeasureResult

    /* ... */
}
```

`MeasurePolicy`はメソッドが一つの[Functional interface](https://kotlinlang.org/docs/fun-interfaces.html)になっており、`measure`メソッドには引数が２つあります。

１つ目の`measurables`は`content`に指定したComposableが測定可能な状態になったものです。

2つ目の`constraints`は配置するための制約で、`maxWidth`や`minHeight`が入っています。

`Measurable`は`constraints`を指定して`meausre`することで、配置可能な`Placeable`に変換させることができます。

```kotlin
interface Measurable : IntrinsicMeasurable {
    fun measure(constraints: Constraints): Placeable
}
```

上記の例だと、このように計測します。

```kotlin
measurePolicy = { measurables, constraints ->
    val titleMeasurable = measurables[0]
    val buttonMeasurable = measurables[1]
    // 子コンポーネントはminWidth, minHeightは無視するので0を指定する
    val buttonConstraints = constraints.copy(
        minHeight = 0,
        minWidth = 0
    )
    val buttonPlaceable = buttonMeasurable.measure(buttonConstraints)
    // 左右にボタンの幅分だけ余白を用意するので、ボタンの幅 * 2だけ引く
    // maxWidthは0未満にできないのでmaxOfで0以上にする
    val titleConstraints = constraints.copy(
        maxWidth = maxOf(constraints.maxWidth - buttonPlaceable.width * 2, 0),
        minHeight = 0,
        minWidth = 0
    )
    val titlePlaceable = titleMeasurable.measure(titleConstraints)
    /* ... */
```


ポイントは、左右にボタン幅の余白を用意するため、Titleの最大横幅をボタンの横幅 * 2だけ引いた値にします。

![](https://cdn.at-sushi.work/temp/2022-12-04-4.png)

先程はindexで`titleMeasurable`と`buttonMeasurable`を取得しましたが、 `Modifier.layoutId`を使うことで、`measurables`からidベースで検索することができます。

```kotlin
    Layout(
        modifier = /* ... */,
        content = {
            Text(
                modifier = Modifier.layoutId("title"),
                text = "Title",
                overflow = TextOverflow.Ellipsis,
                maxLines = 1
            )
            TextButton(
                modifier = Modifier.layoutId("button"),
                onClick = { /* ... */ }
            ) {
                Text(text = "Button")
            }
        },
        measurePolicy = { measurables, constraints ->
            val titleMeasurable = measurables.find { it.layoutId == "title" }
                ?: error("title not found")
            val buttonMeasurable = measurables.find { it.layoutId == "button" }
                ?: error("button not found")
            /* ... */
```


### 2. ノード自体のサイズを決定する

次に、ノード自体(Layout Composable)のサイズを決定します。

今回は、横幅は最大まで広げたいため、`constraints.maxWidth`を指定します。

縦幅はコンテンツサイズに合わせるため、`constraints.minHeight`と`titlePlaceable.height`と`buttonPlaceable.height`の最大値を取るようにします。

決定したサイズは`layout`関数に指定します。

```kotlin
measurePolicy = { measurables, constraints ->
    /* ... */

    // 横幅：最大幅
    val width = constraints.maxWidth
    // 高さ：コンテンツサイズに合わせる
    val height = maxOf(
        constraints.minHeight,
        titlePlaceable.height,
        buttonPlaceable.height
    )
    layout(width, height) {
        /* ... */
    }
}
```


### 3. 子を配置する

最後に、`layout`のラムダ式内で`Placeable.place`を呼び出すことで配置します。

```kotlin
abstract class PlacementScope {
    fun Placeable.place(x: Int, y: Int, zIndex: Float = 0f) = /* ... */

    fun Placeable.place(position: IntOffset, zIndex: Float = 0f) = /* ... */

    /* ... */
}
```

タイトルは中央に配置したいので`Alignment.Center`を、ボタンは左端に配置したいので`Alignment.CenterEnd`を使ってそれぞれの`offset`を計算します。

```kotlin
measurePolicy = { measurables, constraints ->
    /* ... */
    layout(width, height) {
        val space = IntSize(width, height)
        val titleSize = IntSize(titlePlaceable.width, titlePlaceable.height)
        val buttonSize = IntSize(buttonPlaceable.width, buttonPlaceable.height)
        val titleOffset = Alignment.Center.align(titleSize, space, layoutDirection)
        val buttonOffset = Alignment.CenterEnd.align(buttonSize, space, layoutDirection)

        titlePlaceable.place(titleOffset)
        buttonPlaceable.place(buttonOffset)
    }
}
```

ソースコードの全体は[こちら](https://github.com/Mori-Atsushi/jetpack-compose-uis/blob/main/app/src/main/kotlin/com/github/moriatsushi/compose/uis/layout/TitleLayout.kt)から確認できます。

## まとめ
Layout Composableは少し複雑ですが、うまく使えると複雑なレイアウト配置を行うことができます。

`Row`や`Column`といった標準Composableも内部ではLayout Composableを呼び出しています。

`measurePolicy`内の配置の計算は複雑になりがちですが、`maxOf`や`Alignment`を使うことで整理することができるかもしれません。

Layout Composableよりもさらに高機能な`SubcomposeLayout`というものもあるので、今後紹介しようと思います。