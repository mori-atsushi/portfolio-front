---
title: 'OnLifecycleEventより、DefaultLifecycleObserverを使おう'
description: 'Androidの複雑なlifecycleに対応するのに、jetpackのLifecycleObserver等の仕組みは非常に強力です。\nLifecycleObserverにはいくつか種類がありますが、LifecycleObserverのinterfaceにOnLifecycleEventのアノテーションを付けてやる方法が一番一般的だと思っていました。\nしかし、java 8環境下ではDefaultLifecycleObserverのほうが強く推奨されていたので、その説明と、移行に関する注意点をまとめてみます。'
pubDate: '2020-09-13T10:00:00.000Z'
ogpImage: '../../assets/2020-09-13-ogp.png'
---

Androidの複雑なlifecycleに対応するのに、jetpackのLifecycleObserver等の仕組みは非常に強力です。

LifecycleObserverにはいくつか種類がありますが、LifecycleObserverのinterfaceにOnLifecycleEventのアノテーションを付けてやる方法が一番一般的だと思っていました。

しかし、java 8環境下ではDefaultLifecycleObserverのほうが強く推奨されていたので、その説明と、移行に関する注意点をまとめてみます。

## OnLifecycleEventとDefaultLifecycleObserverの比較
Java 7 では、以下のように[OnLifecycleEvent](https://developer.android.com/reference/androidx/lifecycle/OnLifecycleEvent) のアノテーションを使ってLifecycleObserverを作成します。

```kotlin
class TestObserver: LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop(owner: LifecycleOwner) {
         // code
    }
}
```

引数がなくても動いたり、
```kotlin
class TestObserver: LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop() {
         // code
    }
}
```

ON_ANYというイベントも設定できるが面白いですね
```kotlin
class TestObserver: LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    fun onAny(source: LifecycleOwner, event: Event) {
         // code
    }
}
```

Java 8環境下では[DefaultLifecycleObserver](https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver)を使って以下のように書けます。
```kotlin
class TestObserver: DefaultLifecycleObserver {
   override fun onStop(owner: LifecycleOwner) {
         // code
    }
}
```

アノテーションがなくなりすっきりし、また引数等を間違えることがなくなりました。

これは、Java 8からinterfaceのデフォルト実装が可能になったことで実現されています。

DefaultLifecycleObserverの説明に、
```text
If you use Java 8 language, always prefer it over annotations.
```
とあるように、Java 8を使ってる場合は常にDefaultLifecycleObserverが推奨されます。

androidアプリ開発を必ずしもJava 8でする必要はないと思いますが、多くの場合Java 8で開発されることが多くなってきていると思います。

その場合、DefaultLifecycleObserverを使うようにしましょう。

## 移行方法
Java 8が有効になってない場合は、app moduleのbuild.gradleに以下を追記してください。
```groovy
android {
  …
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
```

Lifecycleの依存関係を修正します
```diff
dependencies {
  ...
-  kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
+  implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"
}
```

アノテーションは必要なくなったので、kaptは外して、代わりにJava 8用の依存関係を追加します。

あとはDefaultLifecycleObserverに修正していくだけです。

1点、`lifecycle-compiler` を消してもbuildは通るが、イベントが正しく動かなくなるので注意してください。

## まとめ
僕が長らく勘違いしていたことをまとめてみました。（ドキュメントはちゃんと読みましょう）

なにか参考になれば幸いです。