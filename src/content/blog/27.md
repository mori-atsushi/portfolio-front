---
title: 'StateFlowの深堀り、SharedFlowとの違いとstateIn【kotlin coroutines flow】'
description: 'StateFlowはkotlin corouteinsの1.3.6で追加された状態管理用の特別なFlowです。\n以前、「StateFlowのドキュメントを読み込む」という記事を書きましたが、その後SharedFlowが追加され、若干実装に変更がありました。\nまた、新たにstateInというoperatorも追加されています。\n今回はそれらを含めたStateFlowの詳細な仕様に関して深堀りしていきたいと思います。'
pubDate: '2020-11-15T10:00:00.000Z'
updatedDate: '2021-01-31T06:00:00.000Z'
ogpImage: 'https://cdn.at-sushi.work/temp/2020-11-15-ogp.png'
---

[StateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html)は[kotlin corouteinsの1.3.6](https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.3.6)で追加された状態管理用の特別なFlowです。

以前、「[StateFlowのドキュメントを読み込む](https://at-sushi.work/blog/13)」という記事を書きましたが、その後[SharedFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/index.html)が追加され、若干実装に変更がありました。

また、新たに[stateIn](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html)というoperatorも追加されています。

今回はそれらを含めたStateFlowの詳細な仕様に関して深堀りしていきたいと思います。

Flow, SharedFlow, StateFlowの比較は[こちらの記事](https://at-sushi.work/blog/24)を、SharedFlowの深堀りは[こちらの記事](https://at-sushi.work/blog/25)を参考にしてください。

## StateFlowの基本的な使い方
StateFlowは状態管理に特化したFlowです。

StateFlowは[MutableStateFlow](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/)を使うことで作成することができます。

```kotlin
val mutableStateFlow = MutableStateFlow(0)

mutableStateFlow.onEach {
    println("onEach1:$it")
}.launchIn(GlobalScope)

runBlocking { delay(100) } // 処理が終わるまでちょっと待つ
mutableStateFlow.value = 1

mutableStateFlow.onEach {
    println("onEach2:$it")
}.launchIn(GlobalScope)

runBlocking { delay(100) } // 処理が終わるまでちょっと待つ
mutableStateFlow.value = 2
runBlocking { delay(100) } // 処理が終わるまでちょっと待つ
```
```text
onEach1:0
onEach1:1
onEach2:1
onEach2:2
onEach1:2
```

StateFlowには必ず初期値があり、最新の1つの値を新しいサブスクライバーにreplayする特徴があります。

また、同じ値は流れない、連続して値が変更されると、最後の値のみ流れてくる、といった特徴があります。

## SharedFlowとの違い
StateFlowはSharedFlowを継承しており、SharedFlowの一部という立ち位置です。

```kotlin
interface StateFlow<out T> : SharedFlow<T>
```

SharedFlowを以下のように使うことで、StateFlowと同じ動作をします。
```kotlin
val shared = MutableSharedFlow(
    replay = 1,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)
shared.tryEmit(initialValue)
val state = shared.distinctUntilChanged()
```

SharedFlowを継承しているため、SharedFlowと同じ操作が行えますが、 [resetReplayCache](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/reset-replay-cache.html) はサポートしていないことに注意してください。
```kotlin
override fun resetReplayCache() {
    throw UnsupportedOperationException("MutableStateFlow.resetReplayCache is not supported")
}
```

また、[emit](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html)や[tryEmit](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/try-emit.html)も行うことができますが、内部で[value](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/value.html)が呼ばれるだけなので、使う意味はなさそうです。

わかりにくいので、必ず `value` で操作するようにしたほうが良いと思います。
```kotlin
override suspend fun emit(value: T) {
    this.value = value
}
```

## stateIn
通常のFlowをStateFlowにするために、 [stateIn](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html)というoperatorを使うことができます。

`stateIn` にはsuspend functionのものと、通常関数のものがあります。

通常関数の定義はこうなっています。
```kotlin
fun <T> Flow<T>.stateIn(
    scope: CoroutineScope,
    started: SharingStarted,
    initialValue: T
): StateFlow<T> (source)
```

このように使うことができます。
```kotlin
val flow = flow {
    delay(10)
    emit(1)
    delay(10)
    emit(2)
}
val stateFlow = flow.stateIn(
    scope = GlobalScope,
    started = SharingStarted.Eagerly,
    initialValue = 0
)

stateFlow.onEach {
    println("onEach:$it")
}.launchIn(GlobalScope)

runBlocking { delay(100) } // 処理が終わるまでちょっと待つ
```
```text
onEach:0
onEach:1
onEach:2
```

coroutine scopeと初期値が必須で、startedによってhot stream化するタイミングを変更することができます。

[Eagerly](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-eagerly.html), [Lazily](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-lazily.html), [WhileSubscribed](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html)から選ぶことができます。

もう一つのsuspend functionのstateInの定義は、このようになっています。
```kotlin
public suspend fun <T> Flow<T>.stateIn(scope: CoroutineScope): StateFlow<T>
```

このように使うことができます。
```kotlin
val flow = flow {
    delay(10)
    emit(1)
    delay(10)
    emit(2)
}

runBlocking {
    val stateFlow = flow.stateIn(GlobalScope)

    stateFlow.onEach {
        println("onEach:$it")
    }.launchIn(GlobalScope)

    delay(100) // 処理が終わるまでちょっと待つ
}
```
```text
onEach:1
onEach:2
```

初期値もstartedもいらないのが特徴的ですが、suspend functionのため、若干使いづらいと思います。

## ConflatedBroadcastChannel
StateFlowが登場するまで利用していた [ConflatedBroadcastChannel](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-conflated-broadcast-channel/) は、StateFlowがstableになるタイミングでdeprecatedになることが決定しています。

StateFlowになったことで、シンプルで使いやすく変わっていると思います。

一方で、初期値が必須になったり、closeできなくなってる点には注意してください。

## その他注意点
以下のoperatorはStateFlowで使えません。

 * [flowOn](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html) 
 * [conflate](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html) 
 * [buffer](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html) with [CONFLATED](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/-c-o-n-f-l-a-t-e-d.html) or [RENDEZVOUS](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/-r-e-n-d-e-z-v-o-u-s.html) capacity
 * [distinctUntilChanged](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html)
 * [cancellable](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html) 

Flowにキャストしなおせばコンパイルは通りますが、streamに変化を与えません。

## まとめ
今回はStateFlowに関して深堀りしてみました。

SharedFlowを継承することで、若干挙動が変わったところがあるので、注意が必要です。

また、 `stateIn` 等は結構頻繁に使うのではないかなと思っています。

個人的にはこのような拡張関数を用意して使おうかなと考えています。
```kotlin
fun <T> Flow<T>.stateIn(scope: CoroutineScope): StateFlow<T?> {
    return stateIn(scope, SharingStarted.Eagerly, null)
}
```

ぜひ、SharedFlow、StateFlowを使ったアプリケーション開発にチャレンジしてみてください。

**- 2021/01/31追記- **

Kotlin Coroutinesの解説本をZennにて販売しています。より詳しく学びたい方は、こちらも合わせて確認してみて下さい。

[![](https://cdn.at-sushi.work/temp/zenn-coroutines-pr.png)](https://zenn.dev/at_sushi_at/books/edf63219adfc31)
[詳解 Kotlin Coroutines \[2021\] | Zenn](https://zenn.dev/at_sushi_at/books/edf63219adfc31)
