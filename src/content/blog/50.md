---
title: 'Jetpack ComposeのRippleエフェクトを深堀り、カスタマイズも'
description: 'ユーザが何かをタップしたときにフィードバックを返すことは、正常に入力できたことをユーザに伝えるだけでなく、心地よい操作感やリッチ感を実現するためにも重要です。\nMaterialDesignでは、クリック時に波紋状のRippleエフェクトを表示します。\nJetpack ComposeでもMaterialThemeを利用している場合、クリック可能なコンポーネントはRippleエフェクトが表示されます。\n今回はJetpack ComposeでRippleエフェクトについて色々深堀りをしていき、Rippleの色を変えたり、そもそもタップ時のエフェクトを変更する方法についても紹介します。'
pubDate: '2022-02-13T00:00:00.000Z'
ogpImage: '../../assets/2022-02-13-ogp.png'
---

ユーザが何かをタップしたときにフィードバックを返すことは、正常に入力できたことをユーザに伝えるだけでなく、心地よい操作感やリッチ感を実現するためにも重要です。

[MaterialDesign](https://material.io/)では、クリック時に波紋状のRippleエフェクトを表示します。

[Jetpack Compose](https://developer.android.com/jetpack/compose)でも[MaterialTheme](https://developer.android.com/reference/kotlin/androidx/compose/material/MaterialTheme)を利用している場合、クリック可能なコンポーネントはRippleエフェクトが表示されます。

今回はJetpack ComposeでRippleエフェクトについて色々深堀りをしていき、Rippleの色を変えたり、そもそもタップ時のエフェクトを変更する方法についても紹介します。

## Rippleエフェクトを表示する
Jetpack Composeでは[Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier)の[clickable](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?hl=ja#(androidx.compose.ui.Modifier).clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))を指定すると、同時にRippleエフェクトも表示されます。

`MaterialTheme`の中でないとRippleにならないことに注意してください。

```kotlin
MaterialTheme {
    Text(
        modifier = Modifier
            .clickable(onClick = {})
            .padding(horizontal = 8.dp, vertical = 4.dp),
        text = "Click!"
    )
}
```

<video width="360px" height="760px" src="/videos/2022-02-13-1.mp4" controls></video>

もちろん、[Button](https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.material.ButtonElevation,androidx.compose.ui.graphics.Shape,androidx.compose.foundation.BorderStroke,androidx.compose.material.ButtonColors,androidx.compose.foundation.layout.PaddingValues,kotlin.Function1))や [Checkbox](https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#Checkbox(kotlin.Boolean,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.material.CheckboxColors)) 等のMaterialのコンポーネントにもRippleエフェクトが表示されます。

## デフォルトのRippleの色定義について
Rippleの色や透明度は [RippleTheme](https://developer.android.com/reference/kotlin/androidx/compose/material/ripple/RippleTheme)というinterfaceで定義されています。

```kotlin
public interface RippleTheme {
    @Composable
    public fun defaultColor(): Color

    @Composable
    public fun rippleAlpha(): RippleAlpha
}
```

そしてデフォルトの色と透明度は以下のとおりです。

```kotlin
public fun defaultRippleColor(
    contentColor: Color,
    lightTheme: Boolean
): Color {
    val contentLuminance = contentColor.luminance()
    return if (!lightTheme && contentLuminance < 0.5) {
        Color.White
    } else {
        contentColor
    }
}

public fun defaultRippleAlpha(
    contentColor: Color,
    lightTheme: Boolean
): RippleAlpha {
    return when {
        lightTheme -> {
            if (contentColor.luminance() > 0.5) {
                LightThemeHighContrastRippleAlpha
            } else {
                LightThemeLowContrastRippleAlpha
            }
        }
        else -> {
            DarkThemeRippleAlpha
        }
    }
}
```

引数の `contentColor`は文字色やアイコン色のことで、`lightTheme`はdarkテーマかlightテーマかを渡します。

透明度は以下のように定義されています。

```kotlin
private val LightThemeHighContrastRippleAlpha = RippleAlpha(
    pressedAlpha = 0.24f,
    focusedAlpha = 0.24f,
    draggedAlpha = 0.16f,
    hoveredAlpha = 0.08f
)

private val LightThemeLowContrastRippleAlpha = RippleAlpha(
    pressedAlpha = 0.12f,
    focusedAlpha = 0.12f,
    draggedAlpha = 0.08f,
    hoveredAlpha = 0.04f
)

private val DarkThemeRippleAlpha = RippleAlpha(
    pressedAlpha = 0.10f,
    focusedAlpha = 0.12f,
    draggedAlpha = 0.08f,
    hoveredAlpha = 0.04f
)
```

すなわち、まとめると以下のようになります。

* 色
    * ダークテーマ
         * 文字色の輝度が低い場合は白色
        * それ以外の場合は文字色と同じ
    * ライトテーマ
        * 常に文字色と同じ
* 透明度
    * ダークテーマ
        * 常に10%
    * ライトテーマ
        * 文字色の輝度が高い場合は24%
        * 文字色の輝度が低いときは12%

少し複雑ですが、文字色の輝度によって出し分けすることにより、Rippleや文字を見えやすくする工夫がされています。

この恩恵を最大限に得るためには、文字色を指定する際に直接指定するのではなく、[LocalContentColor](https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#LocalContentColor())を上書きすべきでしょう。

```kotlin
MaterialTheme {
    CompositionLocalProvider(
        LocalContentColor provides Color.Red
    ) {
        Text(
            modifier = Modifier
                .clickable(onClick = {}) // 赤色のRippleが出る
                .padding(horizontal = 8.dp, vertical = 4.dp),
            text = "button" // 赤色の文字色
        )
    }
}
```

文字色と同時にRippleのエフェクト色も変わってることがわかると思います。

<video width="360px" height="760px" src="/videos/2022-02-13-2.mp4" controls></video>

## Rippleの色を変える
これまでの説明で大体わかってきたと思いますが、`RippleTheme`を上書きすることでRippleの色、透明度を変えることができます。

例えば、以下のように`defaultColor`をoverrideします。透明度は`defaultRippleAlpha`に従うで良いでしょう。

```kotlin
object CustomRippleTheme : RippleTheme {
    @Composable
    override fun defaultColor(): Color {
        return Color.Red
    }

    @Composable
    override fun rippleAlpha(): RippleAlpha {
        return RippleTheme.defaultRippleAlpha(
            contentColor = LocalContentColor.current,
            lightTheme = MaterialTheme.colors.isLight
        )
    }
}
```

これを`CompositionLocalProvider`を使って配ります。`MaterialTheme`に上書きされないよう、`MaterialTheme`の内側に指定する必要があります。

```kotlin
MaterialTheme {
    CompositionLocalProvider(
        LocalRippleTheme provides CustomRippleTheme
    ) {
        Text(
            modifier = Modifier
                .clickable(onClick = {})
                .padding(horizontal = 8.dp, vertical = 4.dp),
            text = "button"
        )
    }
}
```

文字色は変えずにRippleだけ赤色にすることができました。

<video width="360px" height="760px" src="/videos/2022-02-13-3.mp4" controls></video>

アプリ全体ではなく、一箇所だけRippleの色を変えたい場合は`indication`に[rememberRipple](https://developer.android.com/reference/kotlin/androidx/compose/material/ripple/package-summary#rememberRipple(kotlin.Boolean,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color)) を指定します。
[InteractionSource](https://developer.android.com/reference/kotlin/androidx/compose/foundation/interaction/InteractionSource)も同時に指定する必要があることに注意してください。

```kotlin
MaterialTheme {
    Text(
        modifier = Modifier
            .clickable(
                onClick = {},
                indication = rememberRipple(color = Color.Red),
                interactionSource = remember { MutableInteractionSource() }
            )
            .padding(horizontal = 8.dp, vertical = 4.dp),
        text = "button"
    )
}
```

結果は先程と同じく赤色のRippleが表示されます。

## Rippleの他のカスタマイズ

`rememberRipple`には`color`の他に`radius`と`bounded`を指定することができます。
`bounded`を`false`にすることで領域を超えた円形のrippleが表示されます。
クリック可能なアイコン等にはこちらのほうが合うかもしれません。

```kotlin
MaterialTheme {
    Text(
        modifier = Modifier
            .clickable(
                onClick = {},
                indication = rememberRipple(bounded = false),
                interactionSource = remember { MutableInteractionSource() }
            )
            .padding(horizontal = 8.dp, vertical = 4.dp),
        text = "button"
    )
}
```

<video width="360px" height="760px" src="/videos/2022-02-13-4.mp4" controls></video>

## クリック時のエフェクトを作る
更にこだわってRippleエフェクト以外のクリック時エフェクトを作成してみます。

以下のようなタップ時にコンポーネントが縮小され、タップを離したときにもとに戻るような `Indicator` を作成してみます。

<video width="360px" height="760px" src="/videos/2022-02-13-5.mp4" controls></video>

タップ等の入力に応じたエフェクトは、`Indication`というinterfaceで定義されています。
`InteractionSource`はタップなどの入力が`Flow`で流れてくるので、それに反応して`IndicationInstance`を作成することで表現します。

```kotlin
@Stable
interface Indication {
    @Composable
    fun rememberUpdatedInstance(
        interactionSource: InteractionSource
    ): IndicationInstance
}
```

`IndicationInstance`はコンテンツをレイアウトに描画するときの操作を記述できます。

```kotlin
interface IndicationInstance {
    fun ContentDrawScope.drawIndication()
}
```

Scaleさせるための実装は以下のとおりです。

`PressInteraction.Press`が発生したらアニメーションを開始し、`PressInteraction.Release`か`PressInteraction.Cancel`で停止します。
アニメーションはいくつかの方法で行うことができますが、ここでは[Animatable](https://developer.android.com/jetpack/compose/animation#animatable)を使って行います。
短いタップでもアニメーションを見せるため、`minDuration`を指定できるようにしています。

```kotlin
class ScaleIndication(
    private val pressedScale: Float,
    private val animationSpec: AnimationSpec<Float>,
    private val minDuration: Long
) : Indication {
    @Composable
    override fun rememberUpdatedInstance(
        interactionSource: InteractionSource
    ): IndicationInstance {
        val instance = remember(pressedScale, animationSpec, minDuration) {
            ScaleIndicationInstance(pressedScale, animationSpec, minDuration)
        }
        LaunchedEffect(interactionSource) {
            interactionSource.interactions.collect {
                when (it) {
                    is PressInteraction.Press -> {
                        instance.start(this)
                    }
                    is PressInteraction.Release,
                    is PressInteraction.Cancel -> {
                        instance.stop()
                    }
                }
            }
        }
        return instance
    }
}

private class ScaleIndicationInstance(
    private val pressedScale: Float,
    private val animationSpec: AnimationSpec<Float>,
    private val minDuration: Long
) : IndicationInstance {
    companion object {
        private const val initialScale = 1.0F
    }

    private var animatable = Animatable(initialScale)
    private var finishEvent = Channel<Unit>(Channel.CONFLATED)

    fun start(scope: CoroutineScope) {
        scope.launch {
            animatable.animateTo(pressedScale, animationSpec)
        }
        scope.launch {
            delay(minDuration)
            finishEvent.receive()
            animatable.animateTo(initialScale, animationSpec)
        }
    }

    fun stop() {
        finishEvent.trySend(Unit)
    }

    override fun ContentDrawScope.drawIndication() {
        val scale = animatable.value
        if (scale != initialScale) {
            drawContext.transform.apply {
                scale(scale)
            }
        }
        drawContent()
    }
}
```

以下のようなComposable functionを用意しておくと使いやすいと思います。`animationSpec`に`dampingRatio`を調整した`spring`を指定することで、例のようにバウンズさせることができます。

```kotlin
@Composable
fun rememberScaleIndication(
    pressedScale: Float = 0.88F,
    animationSpec: AnimationSpec<Float> = spring(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessLow,
    ),
    minDuration: Long = 150
): Indication {
    return remember(pressedScale, animationSpec, minDuration) {
        ScaleIndication(pressedScale, animationSpec, minDuration)
    }
}
```

利用はRippleの変更と同じく、以下のように行います。
`LocalIndicator`を上書きしても良いでしょう。

```kotlin
MaterialTheme {
    Text(
        modifier = Modifier
            .clickable(
                onClick = {},
                indication = rememberScaleIndication(),
                interactionSource = remember { MutableInteractionSource() }
            )
            .background(Color.Blue, RoundedCornerShape(50))
            .padding(horizontal = 16.dp, vertical = 8.dp),
        text = "Button",
        fontSize = 20.sp,
        fontWeight = FontWeight.Bold,
        color = Color.White
    )
}
```

動作するコードは[GitHub](https://github.com/Mori-Atsushi/jetpack-compose-uis/blob/main/app/src/main/kotlin/com/github/moriatsushi/compose/uis/indication/ScaleIndication.kt)で確認できます。

今回はわかりやすさのために省略しましたが、実際には`Focused`や`Hovered`のタイミングでもインタラクションを行うべきでしょう。

## まとめ
よく使うであろうRipple Effectについて色々見てきました。

[前回の記事](https://at-sushi.work/blog/49/)でも言及しましたが、Jetpack Composeはカスタマイズがしやすく、いろいろな表現を試したくなります。
特にアニメーションはKotlin Coroutinesで書くことが出来るので、かなり書きやすくなったと感じています。

ぜひ皆さんも様々なインタラクションを作成してみてください。