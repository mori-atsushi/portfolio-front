---
title: 'Jetpack Composeのコンポーネントはなぜ返り値がないのか'
description: '先週、「Jetpack Compose, React, Flutter, SwiftUIを比較する」という記事で宣言的UIの各ツールの比較を行いました。\nその中で、Jetpack Compose特有の特徴としてコンポーネントに返り値がないことを紹介しました。\nこれは、React等で遵守されてきたコンポーネントは純粋関数として扱うというルールから逸脱したものとなります。\nその理由について、Jetpack Composeの開発に携わるJim SprochさんからTwitterでリプライを頂きました。\n今回はその内容について1つずつ深堀りしていきます。\n'
pubDate: '2021-09-12T06:00:00.000Z'
ogpImage: 'https://cdn.at-sushi.work/temp/2021-09-12-ogp.png'
---

先週、「[Jetpack Compose, React, Flutter, SwiftUIを比較する](https://at-sushi.work/blog/38)」という記事で宣言的UIの各ツールの比較を行いました。

その中で、Jetpack Compose特有の特徴としてコンポーネントに返り値がないことを紹介しました。

```kotlin
@Composable
fun Greeting(name: String) {
    Text("Hello $name")
}
```

これは、React等で遵守されてきたコンポーネントは純粋関数として扱うというルールから逸脱したものとなります。

その理由について、Jetpack Composeの開発に携わる[Jim Sproch](https://twitter.com/JimSproch)さんからTwitterで以下のようにリプライを頂きました。SwiftUI

<blockquote class="twitter-tweet" data-conversation="none" data-theme="light"><p lang="en" dir="ltr">Four reasons: (1) more natural for conditionals and loops, where coalescing return values is troublesome (2) prevent people from reading and passing around VDOM nodes (3) VDOM is terrible for garbage collection (4) more optimizable by Compose Compiler static analysis.</p>&mdash; Jim Sproch (@JimSproch) <a href="https://twitter.com/JimSproch/status/1435555380298493954?ref_src=twsrc%5Etfw" target="_blank">September 8, 2021</a></blockquote> 

今回はその内容について1つずつ深堀りしていきます。

## 1.  複雑な条件文やループで、戻り値の合成がより自然に記述できる
> (1)  more natural for conditionals and loops, where coalescing return values is troublesome

これは前回の記事でも少し紹介していました。今回はより踏み込んで、以下のようなコンポーネントを考えます。

* ヘッダとリストを表示する
* リストが空の場合、ヘッダとEmptyを表示する

これをJetpack Composeで記述するとこのようになります。

```kotlin
@Composable
fun List(value: List<Data>) {
    Column {
        Header()
        if (value.isEmpty()) {
            Empty()
            return@Column
        }
        value.forEach {
            Item(it)
        }
    }
}
```

では、仮にComposableは返り値にする必要があったとします。仮定ではあるので擬似的なコードですが、以下のような記述になるでしょう。

```kotlin
@Composable
fun List(value: List<Data>) = Column {
    val composables = mutableListOf<Composable>()
    composables.add(Header())
    if (value.isEmpty()) {
        composables.add(Empty())
        return@Column composables
    }
    composables.addAll(value.map { Item(it) })
    composables
}
```

もう少し良い書き方はあるかもしれませんが、圧倒的に前者の方が書きやすく、読みやすいですね。

### Reactの解決方法
Reactでは、[JSX](https://ja.reactjs.org/docs/introducing-jsx.html)という記法を用意して上記の問題を緩和しています。

複数要素を並べて表示するのはかなり改善されますが、条件分岐やループは苦手な印象があります。

```jsx
function List(value) {
    return (
        <div>
            <Header />
            { value.isEmpty() && <Empty /> }
            { value.map((item) => <Item value={item} />) }
        </div>
    )
}
```

### Flutterの解決方法
FlutterではDart 2.7から追加された、[Collection if](https://dart.dev/guides/language/language-tour#collection-operators)と[Collection for](https://dart.dev/guides/language/language-tour#collection-operators)を使うことで、リストを扱いやすくなります。

```dart
@override
Widget build(BuildContext context) {
  return Column(children: [
    Header(),
    if (value.isEmpty) Empty(),
    for (var i in value) Item(i)
  ]);
}
```

### SwiftUIの解決方法
SwiftUIは[ViewBuilder](https://developer.apple.com/documentation/swiftui/viewbuilder)等の仕組みを導入し、Viewの生成を支援します。

```swift
var body: some View {
    VStack {
        Header()
        if value.isEmpty {
            Empty()
        }
        ForEach(value) { item in
            Item(item)
        }
    }
}
```

`ViewBuilder` の実装の都合上、VStack内に並べられる上限は10までという制約があります。

また、`ForEach` はSwiftUI用に用意されたstructだったりと、若干Swiftの純粋な記法とは異なっています。

---

Jetpack Composeの記法は、純粋なKotlinの記法に従い、シンプルに記述できるメリットがありそうです。

## 2. 仮想DOMを読んだり渡したりすることを防ぐ
> (2) prevent people from reading and passing around VDOM nodes

[仮想DOM](https://ja.reactjs.org/docs/faq-internals.html)とはReactで使われている技術で、実際にレンダリングするために必要な情報を持っています。

ここではコンポーネントの返り値となるものを指してると考えられます。

その返り値を直接書き換えることはできませんし、読み取ることも基本的に行いません。

```jsx
const component = <Sample />;
// 何かを書き込んだり変更することはできない
component.bar = "Hello, World!"
// 読み取ることも通常行わない
const foo = component.foo
```

また、パフォーマンスの都合や複雑なコンポーネントを作成する際、返り値を保持することはありますが、これには一定の複雑さを伴います。

```jsx
const component = <Sample />;
Cache.push(component)
```

Jetpack Composeでは、こういった記法を避け、よりシンプルに扱うことができるようになってると思われます。

ちなみに、返り値を保持する代わりに、Composableメソッドを保持することは可能です。

```kotlin
val component: @Composable () -> Unit = {
    Text("Hello, World!")
}
```

## 3. 仮想DOMはガーベッジコレクションと相性が悪い
> (3) VDOM is terrible for garbage collection

値を返すということは、何かインスタンスを生成して返すことになります。

JVMで動いている限り、ガーベッジコレクションは避けては通れません。オブジェクトが大量に作られると、そのチェックと削除のコストは増えていくことが想像できます。

Jimさんによると、Reactでもパフォーマンスの最大のネックはガベージコレクションだったようです。

<blockquote class="twitter-tweet" data-conversation="none" data-theme="light"><p lang="ja" dir="ltr">はい、私がReact.jsチームに所属していたとき、ガベージコレクションはパフォーマンスの最大のボトルネックでした。 Composeを設計するときにその問題を回避したかったのです。</p>&mdash; Jim Sproch (@JimSproch) <a href="https://twitter.com/JimSproch/status/1435568681510182913?ref_src=twsrc%5Etfw" target="_blank">September 8, 2021</a></blockquote> 

Jetpack Composeではオブジェクトを生成することなく、直接Gap Bufferに値を書き込むことでTree構造を表現しているようでした。

[Under the hood of Jetpack Compose — part 2 of 2 | by Leland Richardson | Android Developers | Medium](https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd)

## 4. Compose Compilerの静的解析による最適化
>  (4) more optimizable by Compose Compiler static analysis.

ここは多くを語られていないので詳細は不明ですが、Compose Compilerはコンパイル時に多くの最適化を実行しています。

例えば、Recompose（再レンダリング時）にComposableを実行する必要があるかないかを判断できる、必要最低限のキャッシュ機構のコードを生成します。

Jetpack Composeは値を返さないため、各Composableを完全に独立させることになります。そういった背景が、より高度な最適化を可能にしているのかもしれません。

この独立性を活かし、並列に配置されたComposableは並列に実行されたりと、柔軟に動作します。([参考](https://developer.android.com/jetpack/compose/mental-model))

```kotlin
@Composable
fun ButtonRow() {
    MyFancyNavigation {
        StartScreen()
        MiddleScreen()
        EndScreen()
    }
}
```

## 純粋関数でなくなるデメリット
ツイート内では述べられていませんでしたが、値を返さないことによるデメリットについても考えてみたいと思います。

値を返さず、直接Treeを操作してると捉えられるため、Composable関数は純粋関数ではなく、副作用を持つメソッドとして考えられます。これによって生じる問題はないのでしょうか？

純粋関数のメリットとして、メンテナンスの容易性やテストの容易性等が挙げられると思います。

まずメンテナンスの容易性について考えます。Composableは副作用を持つメソッドと書きましたが、独自の方法で副作用を持たせることは許されません。副作用自体はCompose Compilerにより実装され、実装者は副作用を記述することも、意識することもほとんどありません。そういった背景から、メンテナンス性が損なわれることは考えにくいでしょう。

次にテストの容易性ですが、以下のように入力に対する出力のテストはできなくなります。

```kotlin
val actual = add(1, 2)
assertThat(actual).isEqual(3)
```

一方で、仮想DOMに対して検証のテストを書くことはほとんどないように思います。Jetpack Composeでも一度レンダリングを行った後にテストを書くようになっています。([参考](https://developer.android.com/jetpack/compose/testing?hl=ja))

```kotlin
class MyComposeTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun MyTest() {
        composeTestRule.setContent {
            MyAppTheme {
                MainScreen(uiState = fakeUiState, /*...*/)
            }
        }

        composeTestRule.onNodeWithText("Continue").performClick()

        composeTestRule.onNodeWithText("Welcome").assertIsDisplayed()
    }
}
```


もう少し検証する必要があるかもしれませんが、大部分において大きな問題は生じないように思います。

## デザインが先、実装が後
<blockquote class="twitter-tweet" data-conversation="none" data-theme="light"><p lang="ja" dir="ltr">本当ですが、原因と結果は重要です。 デザインが最初に来ました。 ギャップバッファは単なる実装の詳細であり、簡単に変更できます。</p>&mdash; Jim Sproch (@JimSproch) <a href="https://twitter.com/JimSproch/status/1435558001964953606?ref_src=twsrc%5Etfw" target="_blank">September 8, 2021</a></blockquote> 

スレッドの議論の中で、興味深いコメントだったため、紹介させてください。

先程も紹介したとおり、Jetpack ComposeはUIの差分更新のためにGap Bufferという仕組みを取り入れています。一方で、これはあくまでも実装の詳細であり、Jetpack Composeのデザインはそれよりも先にあったと述べられています。そのため、異なる差分更新の仕組みを導入することも可能と言われています。

確かにJetpack Composeは値を返さないことで、より高度な最適化ができるようになっているように見えますが、それ以前に使いやすさ、書きやすさを重要視しているようでした。

これは全てのソフトウェアの設計に言えますが、公開されているInterfaceは利用しやすい形にし、実装の詳細は隠蔽することにより、詳細を容易に変更できる、強固で耐久性のある設計になります。

Jetpack Composeの設計や思想を読み解くことで、普段の設計にも活かせるのではないかと感じました。

## まとめ
今回はJetpack Compose特有の性質である、各コンポーネントは値を返さないという設計理由について深堀りを行いました。

値を返さないことにより、様々なことがシンプルになり、高度な最適化も可能であることがわかりました。

個人的には、宣言的UIの新たなパラダイムシフトではないかと感じており、今後様々なプラットフォームに影響を与える可能性もありそうです。

今回Twitterで返信を下さった[Jim Sproch](https://twitter.com/JimSproch)さん、そして議論に参加して下さった[からくり](https://twitter.com/kr9ly)さん, [つかもとたけし](https://twitter.com/itometeam)さんにお礼申し上げます。